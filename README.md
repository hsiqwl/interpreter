# interpreter
Interpreter for my own language 

В этом репозитории находятся файлы по проекту реализованному в рамках курса теории автоматов. Был разработан интерпретатор собственного языка программирования на С++.

***Описание языка***:
    - **Использование литералов**:
      - Использование знаковых и беззнаковых литералов в десятичном формате, по умолчанию литералы знаковые, для объявления беззнаковых используется суффикс ‘u’;  
      - Использование литерала типа Cell: ```(top|ntop, right|nright, down|ndown, left|nleft)]```; top|ntop,.. указывают на наличие или отсутствие соответствующей стенки, указываются в любом порядке, могут отсутствовать, по умолчанию стенки отсутствуют; дублирование противоречивых указаний на наличие стенки в одном кортеже недопустимо и является семантической ошибкой.

    - **Объявление переменных и констант в форматах**:
      - Целочисленная переменная со знаком ```[const] signed <имя переменной> [ <- <арифметическое выражение>]```, const – указание на то, что идентификатор является константой, поле инициализации при этом обязательно
      - Целочисленная переменная без знака ```[const] unsigned <имя переменной> [ <- <арифметическое выражение>]```
      - Элемент карты мира ```[const] Сell [<- <арифметическое выражение>]```
      - Объявление двумерных матриц ```matrix <тип_элемента> <имя переменной> (максимальный индекс по горизонтали, максимальный индекс по вертикали) | matrix <тип_элемента> <имя переменной>```; индексация начинается с 0u;
      - Доступ к элементу матрицы  ```<имя массива> (индекс по горизонтали, индекс по вертикали)```; индексация начинается с 0u;

    - **Преобразование типов:**
      - Применяется преобразование типов между ```signed``` и ```unsigned```, если нельзя выполнить подобное преобразование (выход за разрядную сетку), то это считается ошибкой времени выполнения и программа должна аварийно завершиться; при вычислениях при смешении операндов выполняется продвижение к первому операнду. Для ячеек определено преобразование в целочисленные типы, следующим образом:
        - ```Сell -> signed,unsigned```: 0, если нет стенок; 1, если есть хотя бы одна стенка;
        - ```signed, unsigned -> cell```: ячейка без стенок, если 0; ячейка полностью ограниченная стенками, если значение отлично от 0. Преобразование для матриц определено только если определено преобразование для внутреннего типа, хранимого в матрице.**

  - **Поддерживаемые операторы:**
      -Бинарные операторы сложения, вычитания, умножения, целочисленного деления, получения остатка от деления (+, -, *, /, %); деление и остаток от деления на 0 приводят к ошибке времени выполнения (корректность выражений с нулевыми константными литералами проверяется на этапе первичного сканирования);  операторы для матриц выполняются на поэлементной основе, в рамках минимально допустимых значений индексов; для ячеек определены операторы -,/, % выполняются по семантике исключающего или, + -или, *- и над состояниями наличия/отсутствия стен:
    ```< арифметическое выражение> оператор < арифметическое выражение>```
      - Операторы сравнения (=, <, >), возвращают 1 при выполнении условия и 0 при не выполнении, сравнение для матриц и ячеек не опредлено:
    ```<арифметическое выражение> оператор <арифметическое выражение>```;
(приоритет операторов в порядке убывания (*,/,%),(<,>,=),(+,-) могут применятся операторные скобки ‘(‘ и ’)’, для переопределения порядка вычисления операторов в выражениях).
      - Унарный оператор ```#``` для матриц, для целочисленных элементов вычисляет среднее значение, и записывает во все элементы матрицы, для матрицы ячеек ‘объединяет’ стенки соседних ячеек, т.е. если два соседних элемента матрицы имеют разное состояние смежной стенки, то это состояние исправляется в соответствующей ячейке в пользу его наличия;, возвращает модифицированное состояние матрицы.
   ```oператор <имя переменной>```
      - Oператор цикла  **testrep (<арифметическое выражение>)  <группа предложений>** - выполняется тело цикла до тех пор, пока выражение в условии отлично от 0.
      - Условный оператор  **testonce (арифметическое выражение) <группа предложений>** - выполняется тело оператора, если выражение в условии отлично от 0.
      - Оператор вывода в поток: **print(<выражение>)**. Файл для вывода может быть указан в конфигурационном файле, по умолчанию - стандартный поток вывода.

  - **Поддерживаются объявление и вызов функций:**
      - ```func <имя функции> ( [<тип параметра> <имя параметра>,..]) <группа предложений языка>```. Функция является отдельной областью видимости, параметры передаются в функцию по значению. Возвращаемым значением является результат последнего предложения в теле функции. Объявление функций внутри других функций не допустимо. Точкой входа в программу является функция с именем ```start```.
     - Вызов функции: ```call <имя функции> (<аргументы, разделенные запятой>)```. Вызов функции может быть в любом месте программы, если она была объявлена до вызова.

    - **Cпециальные операторы управления клеточным роботом:**
      - Перемещениe робота на одну клетку в заданном направлении ```move_top```, ```move_bottom```, ```move_left```, ```move_right```;
      - Осмотр ближайших окрестностей c помощью рентгеновского аппарата ```xray```, возвращает матрицу размером 5x5 с состоянием соседних с роботом ячеек, робот находится в центре матрицы

    - Предложения языка оканчиваются символом ';'. Группы предложений объединяются при помощи круглых скобок: '(' <группа предложений языка> ')'

Грамматика языка описана в файле 'grammar.yy'. Парсер для грамматики был сгенерирован с помощью bison, а лексер с помощью flex.

В репозитории находится несколько примеров программ. Файл для исполнения передается через аргумент командной строки.
